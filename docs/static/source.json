{
  "_internal.d.ts": "type Incr = [\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  16,\n  17,\n  18,\n  19,\n  20,\n  21,\n  22,\n  23,\n  24,\n  25,\n  26,\n  27,\n  28,\n  29,\n  30,\n  31,\n  32,\n  33,\n  34,\n  35,\n  36,\n  37,\n  38,\n  39,\n  40,\n  41,\n  42,\n  43,\n  44,\n  45,\n  46,\n  47,\n  48,\n  49,\n  50,\n  51,\n  52,\n  53,\n  54,\n  55,\n  56,\n  57,\n  58,\n  59,\n  60,\n  61,\n  62,\n  63,\n  64,\n  65,\n  66,\n  67,\n  68,\n  69,\n  70,\n  71,\n  72,\n  73,\n  74,\n  75,\n  76,\n  77,\n  78,\n  79,\n  80,\n  81,\n  82,\n  83,\n  84,\n  85,\n  86,\n  87,\n  88,\n  89,\n  90,\n  91,\n  92,\n  93,\n  94,\n  95,\n  96,\n  97,\n  98,\n  99,\n  100,\n  101,\n  102,\n  103,\n  104,\n  105,\n  106,\n  107,\n  108,\n  109,\n  110,\n  111,\n  112,\n  113,\n  114,\n  115,\n  116,\n  117,\n  118,\n  119,\n  120,\n  121,\n  122,\n  123,\n  124,\n  125,\n  126,\n  127,\n  128,\n  129,\n  130,\n  131,\n  132,\n  133,\n  134,\n  135,\n  136,\n  137,\n  138,\n  139,\n  140,\n  141,\n  142,\n  143,\n  144,\n  145,\n  146,\n  147,\n  148,\n  149,\n  150,\n  151,\n  152,\n  153,\n  154,\n  155,\n  156,\n  157,\n  158,\n  159,\n  160,\n  161,\n  162,\n  163,\n  164,\n  165,\n  166,\n  167,\n  168,\n  169,\n  170,\n  171,\n  172,\n  173,\n  174,\n  175,\n  176,\n  177,\n  178,\n  179,\n  180,\n  181,\n  182,\n  183,\n  184,\n  185,\n  186,\n  187,\n  188,\n  189,\n  190,\n  191,\n  192,\n  193,\n  194,\n  195,\n  196,\n  197,\n  198,\n  199,\n  200,\n  201,\n  202,\n  203,\n  204,\n  205,\n  206,\n  207,\n  208,\n  209,\n  210,\n  211,\n  212,\n  213,\n  214,\n  215,\n  216,\n  217,\n  218,\n  219,\n  220,\n  221,\n  222,\n  223,\n  224,\n  225,\n  226,\n  227,\n  228,\n  229,\n  230,\n  231,\n  232,\n  233,\n  234,\n  235,\n  236,\n  237,\n  238,\n  239,\n  240,\n  241,\n  242,\n  243,\n  244,\n  245,\n  246,\n  247,\n  248,\n  249,\n  250,\n  251,\n  252,\n  253,\n  254,\n  255,\n  0\n];\n",
  "basic.tzen": "",
  "index.d.ts": "import '@type-zen/preset-type';\n\nexport type * as Array from './array';\nexport type * as A from './array';\n\nexport type * as Object from './object';\nexport type * as O from './object';\n\nexport type * as String from './string';\nexport type * as S from './string';\n\nexport type * as Number from './number';\nexport type * as N from './number';\n\nexport type * as Utils from './utils.tzen';\n",
  "utils.tzen": "export type Equal<X, Y> =\n  (<T>() => T == X ? 1 : 2) ==\n  (<T>() => T == Y ? 1 : 2) ? true : false\n\nexport type Checker<T: true[]> = T;\n\nexport type Cast<A1: any, A2:any> = A1 == A2 ? A1 : A2\n",
  "utils.tzen.d.ts": "// @ts-nocheck\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\nexport type Checker<T extends true[]> = T;\nexport type Cast<A1 extends any, A2 extends any> = A1 extends A2 ? A1 : A2;",
  "array/index.d.ts": "export type { Length } from './length/index.tzen';\nexport type { Pop } from './pop/index.tzen';\nexport type { Join } from './join/index.tzen';\nexport type { Append } from './append/index.tzen';\nexport type { Concat } from './concat/index.tzen';\nexport type { FillWith } from './fill-with/index.tzen';\nexport type { Slice } from './slice/index.tzen';\nexport type { Chunk } from './chunk/index.tzen';\n",
  "number/index.d.ts": "export type { Range } from './range/index.tzen';\n",
  "object/index.d.ts": "export type { GetWritableKeys } from './get-writable-keys/index.tzen';\nexport type { IsEmpty } from './is-empty/index.tzen';\nexport type { SetWritable } from './set-writable/index.tzen';\nexport type { Simplify } from './simplify/index.tzen';\n",
  "string/_internal.tzen": "\n// source: https://github.com/sindresorhus/type-fest/blob/main/source/internal.d.ts#L50\nexport type Whitespace =\n\t'\\u{9}' // '\\t'\n\t| '\\u{A}' // '\\n'\n\t| '\\u{B}' // '\\v'\n\t| '\\u{C}' // '\\f'\n\t| '\\u{D}' // '\\r'\n\t| '\\u{20}' // ' '\n\t| '\\u{85}'\n\t| '\\u{A0}'\n\t| '\\u{1680}'\n\t| '\\u{2000}'\n\t| '\\u{2001}'\n\t| '\\u{2002}'\n\t| '\\u{2003}'\n\t| '\\u{2004}'\n\t| '\\u{2005}'\n\t| '\\u{2006}'\n\t| '\\u{2007}'\n\t| '\\u{2008}'\n\t| '\\u{2009}'\n\t| '\\u{200A}'\n\t| '\\u{2028}'\n\t| '\\u{2029}'\n\t| '\\u{202F}'\n\t| '\\u{205F}'\n\t| '\\u{3000}'\n\t| '\\u{FEFF}';\n  \nexport type AlphaLowerCaseChars =\n  | 'a'\n  | 'b'\n  | 'c'\n  | 'd'\n  | 'e'\n  | 'f'\n  | 'g'\n  | 'h'\n  | 'i'\n  | 'j'\n  | 'k'\n  | 'l'\n  | 'm'\n  | 'n'\n  | 'o'\n  | 'p'\n  | 'q'\n  | 'r'\n  | 's'\n  | 't'\n  | 'u'\n  | 'v'\n  | 'w'\n  | 'x'\n  | 'y'\n  | 'z';\n\nexport type AlphaUppercaseChars =\n  | 'A'\n  | 'B'\n  | 'C'\n  | 'D'\n  | 'E'\n  | 'F'\n  | 'G'\n  | 'H'\n  | 'I'\n  | 'J'\n  | 'K'\n  | 'L'\n  | 'M'\n  | 'N'\n  | 'O'\n  | 'P'\n  | 'Q'\n  | 'R'\n  | 'S'\n  | 'T'\n  | 'U'\n  | 'V'\n  | 'W'\n  | 'X'\n  | 'Y'\n  | 'Z';\n\nexport type NumberChars = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';\n\nexport type ExtractTailStr<S: string> = `${any}${S}`\nexport type ExtractHeadStr<S: string> = `${S}${any}`\n\n// 获取除第一个字符外的字符串（尾字符串）\nexport type GetTailStr<S: string> = S == ExtractTailStr<infer T> ? T : never\n// 获取首个字符\nexport type GetHeadStr<S: string> = S == ExtractHeadStr<infer T> ? T : never",
  "string/_internal.tzen.d.ts": "// @ts-nocheck\n\nexport type Whitespace = '\\u{9}' | '\\u{A}' | '\\u{B}' | '\\u{C}' | '\\u{D}' | '\\u{20}' | '\\u{85}' | '\\u{A0}' | '\\u{1680}' | '\\u{2000}' | '\\u{2001}' | '\\u{2002}' | '\\u{2003}' | '\\u{2004}' | '\\u{2005}' | '\\u{2006}' | '\\u{2007}' | '\\u{2008}' | '\\u{2009}' | '\\u{200A}' | '\\u{2028}' | '\\u{2029}' | '\\u{202F}' | '\\u{205F}' | '\\u{3000}' | '\\u{FEFF}';\nexport type AlphaLowerCaseChars = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z';\nexport type AlphaUppercaseChars = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z';\nexport type NumberChars = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';\nexport type ExtractTailStr<S extends string> = `${any}${S}`;\nexport type ExtractHeadStr<S extends string> = `${S}${any}`;\nexport type GetTailStr<S extends string> = S extends ExtractTailStr<infer T> ? T : never;\nexport type GetHeadStr<S extends string> = S extends ExtractHeadStr<infer T> ? T : never;",
  "string/index.d.ts": "export type { Length } from './length/index.tzen';\nexport type { Replace } from './replace/index.tzen';\nexport type { Split } from './split/index.tzen';\nexport type { At } from './at/index.tzen';\nexport type { TrimStart } from './trim-start/index.tzen';\nexport type { TrimEnd } from './trim-end/index.tzen';\nexport type { Trim } from './trim/index.tzen';\nexport type { Repeat } from './repeat/index.tzen';\nexport type { Substring } from './substring/index.tzen';\nexport type { IndexOf } from './index-of/index.tzen';\nexport type { StartsWith } from './starts-with/index.tzen';\nexport type { EndsWith } from './ends-with/index.tzen';\nexport type { SplitWords } from './split-words/index.tzen';\nexport type { CamelCase } from './camel-case/index.tzen';\nexport type { PascalCase } from './pascal-case/index.tzen';\nexport type { KebabCase } from './kebab-case/index.tzen';\nexport type { SnakeCase } from './snake-case/index.tzen';\n",
  "array/append/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Append } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Append<[], 1>, [1]>,\n    Equal<Append<[1], string>, [1, string]>,\n    Equal<Append<string[], { a: 1 }>, [...string[], { a: 1 }]>\n  ]\n>;\n",
  "array/append/index.tzen": "export type Append<Arr: Array<any>, Element> = [...Arr, Element];",
  "array/append/index.tzen.d.ts": "// @ts-nocheck\n\nexport type Append<Arr extends Array<any>, Element> = [...Arr, Element];",
  "array/chunk/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Chunk } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Chunk<[], 1>, []>,\n    Equal<Chunk<[1, 2, 3, 4], 1>, [[1], [2], [3], [4]]>,\n    Equal<Chunk<[1, 2, 3, 4], 2>, [[1, 2], [3, 4]]>,\n    Equal<Chunk<[1, 2, 3, 4], 3>, [[1, 2, 3], [4]]>,\n    Equal<Chunk<[1, 2, 3, 4], 4>, [[1, 2, 3, 4]]>,\n    Equal<Chunk<[1, 2, 3, 4], 5>, [[1, 2, 3, 4]]>\n  ]\n>;\n",
  "array/chunk/index.tzen": "type _Handle<\n  $: { Size: number },\n  ChunkSource: Array<any>,\n  CurChunk: Array<any> = [],\n  Output: Array<Array<any>> = []\n> = ^{\n  if (ChunkSource == [infer H, ...infer T]) {\n    if (CurChunk['length'] == $['Size']) {\n      return _Handle<$, T, [H], [...Output, CurChunk]>\n    } else {\n      return _Handle<$, T, [...CurChunk, H], Output>\n    }\n  } else {\n    return CurChunk['length'] == 0 ? Output : [...Output, CurChunk]\n  }\n}  \n\nexport type Chunk<Arr: Array<any>, Size: number> = _Handle<{ Size: Size }, Arr>",
  "array/chunk/index.tzen.d.ts": "// @ts-nocheck\n\ntype _Handle<$ extends {\n  Size: number;\n}, ChunkSource extends Array<any>, CurChunk extends Array<any> = [], Output extends Array<Array<any>> = []> = ChunkSource extends [infer H, ...infer T] ? CurChunk['length'] extends $['Size'] ? _Handle<$, T, [H], [...Output, CurChunk]> : _Handle<$, T, [...CurChunk, H], Output> : CurChunk['length'] extends 0 ? Output : [...Output, CurChunk];\nexport type Chunk<Arr extends Array<any>, Size extends number> = _Handle<{\n  Size: Size;\n}, Arr>;",
  "array/concat/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Concat } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Concat<[], []>, []>,\n    Equal<Concat<[], [1]>, [1]>,\n    Equal<Concat<[1], []>, [1]>,\n    Equal<Concat<[1], [2, 3, 4, ['..'?]]>, [1, 2, 3, 4, ['..'?]]>,\n    Equal<Concat<[1, 2, 3, ['..'?]], [4]>, [1, 2, 3, ['..'?], 4]>,\n    Equal<Concat<[number, string], [boolean, symbol]>, [number, string, boolean, symbol]>\n  ]\n>;\n",
  "array/concat/index.tzen": "export type Concat<Arr1: Array<any>, Arr2: Array<any>> = [...Arr1, ...Arr2]",
  "array/concat/index.tzen.d.ts": "// @ts-nocheck\n\nexport type Concat<Arr1 extends Array<any>, Arr2 extends Array<any>> = [...Arr1, ...Arr2];",
  "array/fill-with/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { FillWith } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<FillWith<'a', 3>, ['a', 'a', 'a']>,\n    Equal<FillWith<1, 3>, [1, 1, 1]>,\n    Equal<FillWith<true, 3>, [true, true, true]>\n  ]\n>;\n",
  "array/fill-with/index.tzen": "type _Handle<\n  $: { Element: any, Length: number },\n  Output: Array<any> = []\n> = ^{\n  if (Output['length'] == $['Length']) {\n    return Output\n  } else {\n    return _Handle<$, [...Output, $['Element']]>\n  }\n}\n\nexport type FillWith<Element, Length: number> = _Handle<{ Element: Element, Length: Length }>",
  "array/fill-with/index.tzen.d.ts": "// @ts-nocheck\n\ntype _Handle<$ extends {\n  Element: any;\n  Length: number;\n}, Output extends Array<any> = []> = Output['length'] extends $['Length'] ? Output : _Handle<$, [...Output, $['Element']]>;\nexport type FillWith<Element, Length extends number> = _Handle<{\n  Element: Element;\n  Length: Length;\n}>;",
  "array/join/index.test.ts": "import type { Checker, Equal } from '../../utils.tzen';\nimport type { Join } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Join<[]>, ''>,\n    Equal<Join<['a'], ','>, 'a'>,\n    Equal<Join<['a', 'b'], ','>, 'a,b'>,\n    Equal<Join<['a', 'b', 'c'], ','>, 'a,b,c'>,\n    Equal<Join<['a', 'b', 'c'], ' '>, 'a b c'>,\n    Equal<Join<['a', 'b', 'c'], ' and '>, 'a and b and c'>,\n    Equal<Join<['a', 'b', 'c'], ' or '>, 'a or b or c'>\n  ]\n>;\n",
  "array/join/index.tzen": "export type Join<\n  Strings: ReadonlyArray<string | number>, \n  Delimiter: string = ''\n> = ^{\n  if (Strings == []) {\n    return ''\n  }\n\n  if (Strings == readonly [string | number]) {\n    return `${Strings[0]}`\n  }\n\n  if (Strings == readonly [string | number, ...infer Rest == ReadonlyArray<string | number>]) {\n    return `${Strings[0]}${Delimiter}${Join<Rest, Delimiter>}`\n  }\n\n  return string\n}",
  "array/join/index.tzen.d.ts": "// @ts-nocheck\n\nexport type Join<Strings extends ReadonlyArray<string | number>, Delimiter extends string = ''> = (Strings extends [] ? '' : TZ_URS) extends infer r_nitf ? r_nitf extends TZ_URS ? (Strings extends readonly [string | number] ? `${Strings[0]}` : TZ_URS) extends infer r_b0xn ? r_b0xn extends TZ_URS ? (Strings extends readonly [string | number, ...infer Rest extends ReadonlyArray<string | number>] ? `${Strings[0]}${Delimiter}${Join<Rest, Delimiter>}` : TZ_URS) extends infer r_csz4 ? r_csz4 extends TZ_URS ? string : r_csz4 : never : r_b0xn : never : r_nitf : never;",
  "array/length/index.test.ts": "import type { Checker, Equal } from '../../utils.tzen';\nimport type { Length } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Length<[]>, 0>,\n    Equal<Length<[1]>, 1>,\n    Equal<Length<[1, 2]>, 2>,\n    Equal<Length<[1, 2, 3]>, 3>\n  ]\n>;\n",
  "array/length/index.tzen": "export type Length<Arr: ReadonlyArray<any>> = Arr['length']",
  "array/length/index.tzen.d.ts": "// @ts-nocheck\n\nexport type Length<Arr extends ReadonlyArray<any>> = Arr['length'];",
  "array/pop/index.test.ts": "import { Checker, Equal } from '../../utils.tzen';\nimport { Pop } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Pop<[1, 2, 3]>, [1, 2]>,\n    Equal<Pop<[1, 2]>, [1]>,\n    Equal<Pop<[1]>, []>,\n    Equal<Pop<[]>, unknown[]>,\n    Equal<Pop<['1', '2', '3', '']>, ['1', '2', '3']>\n  ]\n>;\n",
  "array/pop/index.tzen": "export type Pop<Arr: ReadonlyArray<any>> =^{\n  if (Arr == readonly ([...infer LBody, any] | [...infer LBody, any?])) {\n    return LBody\n  } else {\n    return Arr\n  }\n}",
  "array/pop/index.tzen.d.ts": "// @ts-nocheck\n\nexport type Pop<Arr extends ReadonlyArray<any>> = Arr extends readonly ([...infer LBody, any] | [...infer LBody, any?]) ? LBody : Arr;",
  "array/slice/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Slice } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Slice<[], 0, 0>, []>,\n    Equal<Slice<[1, 2, 3, 4, 5], 1, 3>, [2, 3]>,\n    Equal<Slice<[1, 2, 3, 4, 5], 1, 10>, [2, 3, 4, 5]>,\n    Equal<Slice<[1, 2, 3, 4, 5], 10, 10>, []>\n  ]\n>;\n",
  "array/slice/index.tzen": "import type { Range } from '../../number'\n\ntype _Handle<\n  $: { Arr: Array<any> },\n  ArrRange: number[],\n  Output: Array<any> = [],\n> = ^{\n  if (ArrRange == [infer CurIndex, ...infer NextArrRange]) {\n    if (CurIndex == $['Arr']['length']) {\n      return Output\n    } else {\n      return _Handle<$, NextArrRange, [...Output, $['Arr'][CurIndex]]>\n    }\n  } else {\n    return Output\n  }\n}\n\n\nexport type Slice<Arr: Array<any>, Start: number, End: number> = _Handle<{ Arr: Arr }, Range<Start, End>>",
  "array/slice/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Range } from '../../number';\ntype _Handle<$ extends {\n  Arr: Array<any>;\n}, ArrRange extends number[], Output extends Array<any> = []> = ArrRange extends [infer CurIndex, ...infer NextArrRange] ? CurIndex extends $['Arr']['length'] ? Output : _Handle<$, NextArrRange, [...Output, $['Arr'][CurIndex]]> : Output;\nexport type Slice<Arr extends Array<any>, Start extends number, End extends number> = _Handle<{\n  Arr: Arr;\n}, Range<Start, End>>;",
  "number/range/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Range } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Range<1, 5>, [1, 2, 3, 4]>,\n    Equal<Range<1, 1>, []>,\n    Equal<Range<55, 60>, [55, 56, 57, 58, 59]>,\n    // Equal<Range<1500, 1505>, [1500, 1501, 1502, 1503, 1504]>,\n    Equal<Range<0, 0>, []>,\n    Equal<Range<0, 1>, [0]>,\n    Equal<Range<0, 2>, [0, 1]>,\n    // Equal<Range<1, 2000>['length'], 1999>\n  ]\n>;",
  "number/range/index.tzen": "import type { Incr } from '../../_internal'\n\n// see 「TypeScript 突破类型体操天花板，如何绕过编译器三大限制 - Square的文章 - 知乎」 https://zhuanlan.zhihu.com/p/613266541\n// 一直让内部的条件走 false 分支（if true == false），这样就能扩展默认的递归最大限度（1000）了，但会性能炸裂\ntype _GenerateInternal = { AccCount: 0[], AccRange: number[], InRange: boolean }\ntype _Generate<\n  $: { S: number; E: number },\n  _: _GenerateInternal = { AccCount: [], AccRange: [], InRange: false }\n> = ^{\n    if (true == false) {\n      return never;\n    } else {\n      type CurCount = _['AccCount']['length']\n      type NewAccRange = [..._['AccRange'], CurCount];\n      type NewAccCount = [..._['AccCount'], 0];\n      type NewIterations = Incr[_['Iterations']]\n      \n      if (CurCount == $['E']) {\n        // 不包含最后一个\n        return _['AccRange']\n      } else if (CurCount == $['S']) {\n        return _Generate<$, {\n          AccCount: NewAccCount,\n          AccRange: NewAccRange,\n          InRange: true\n        }>\n      } else if (_['InRange'] == true) {\n        return _Generate<$, {\n          AccCount: NewAccCount,\n          AccRange: NewAccRange,\n          InRange: true\n        }>\n      } else {\n        return _Generate<$, {\n          AccCount: NewAccCount,\n          AccRange: [],\n          InRange: false\n        }> \n      }\n    }\n};\n\nexport type Range<Start: number, End: number> = _Generate<{ S: Start, E: End }>",
  "number/range/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Incr } from '../../_internal';\ntype _GenerateInternal = {\n  AccCount: 0[];\n  AccRange: number[];\n  InRange: boolean;\n};\ntype _Generate<$ extends {\n  S: number;\n  E: number;\n}, _ extends _GenerateInternal = {\n  AccCount: [];\n  AccRange: [];\n  InRange: false;\n}> = true extends false ? never : [_['AccCount']['length'], [..._['AccRange'], _['AccCount']['length']], [..._['AccCount'], 0], Incr[_['Iterations']]] extends [infer CurCount, infer NewAccRange, infer NewAccCount, infer NewIterations] ? CurCount extends $['E'] ? _['AccRange'] : CurCount extends $['S'] ? _Generate<$, {\n  AccCount: NewAccCount;\n  AccRange: NewAccRange;\n  InRange: true;\n}> : _['InRange'] extends true ? _Generate<$, {\n  AccCount: NewAccCount;\n  AccRange: NewAccRange;\n  InRange: true;\n}> : _Generate<$, {\n  AccCount: NewAccCount;\n  AccRange: [];\n  InRange: false;\n}> : never;\nexport type Range<Start extends number, End extends number> = _Generate<{\n  S: Start;\n  E: End;\n}>;",
  "object/get-writable-keys/index.test.ts": "import { Equal, Checker } from '../../utils.tzen';\nimport { GetWritableKeys } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<GetWritableKeys<{ a: 1; b: 2; c: 3 }>, 'a' | 'b' | 'c'>,\n    Equal<GetWritableKeys<{ a: 1; b: 2; c: 3; readonly d: 4 }>, 'a' | 'b' | 'c'>,\n    Equal<\n      GetWritableKeys<{ a: 1; b: 2; c: 3; readonly d: 4; e: 5 }>,\n      'a' | 'b' | 'c' | 'e'\n    >,\n    Equal<\n      GetWritableKeys<{ a: 1; b: 2; c: 3; readonly d: 4; e: 5; readonly f: 6 }>,\n      'a' | 'b' | 'c' | 'e'\n    >,\n    Equal<GetWritableKeys<{ readonly a: 1 }>, never>,\n    Equal<GetWritableKeys<{ readonly a: 1; readonly b: 2 }>, never>,\n    Equal<GetWritableKeys<{ readonly a: 1; readonly b: 2; readonly c: 3 }>, never>,\n    Equal<GetWritableKeys<{ a: 1; b: 2; c: 3 } | { a: 1; b: 2; c: 3 }>, 'a' | 'b' | 'c'>,\n    Equal<\n      GetWritableKeys<{ a: 1; b: 2; c: 3 } | { a: 1; b: 2; c: 3; readonly d: 4 }>,\n      'a' | 'b' | 'c'\n    >,\n    Equal<\n      GetWritableKeys<{ a: 1; b: 2; c: 3 } | { a: 1; b: 2; c: 3; readonly d: 4; e: 5 }>,\n      'a' | 'b' | 'c' | 'e'\n    >\n  ]\n>;\n",
  "object/get-writable-keys/index.tzen": "import type { Equal } from '../../utils.tzen'\n\ntype _Get<O: object> =^{\n  type OKeys = keyof O;\n  \n  type U = {\n    [K in OKeys]-?: ^{\n      type LC = {-readonly [Q in K]: O[K]};\n      type RC = {[Q in K]: O[K]};\n      type IsWritable = Equal<LC, RC>;\n\n      return IsWritable == true ? K : never\n    }\n  };\n\n  return U[OKeys]\n}\n\nexport type GetWritableKeys<O: object> = ^{\n  for (infer Item in O) {\n    return _Get<Item>\n  }\n}",
  "object/get-writable-keys/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Equal } from '../../utils.tzen';\ntype _Get<O extends object> = [keyof O, {\n  [K in keyof O]-?: [{\n  -readonly [Q in K]: O[K];\n}, {\n  [Q in K]: O[K];\n}, Equal<{\n  -readonly [Q in K]: O[K];\n}, {\n  [Q in K]: O[K];\n}>] extends [infer LC, infer RC, infer IsWritable] ? IsWritable extends true ? K : never : never;\n}] extends [infer OKeys, infer U] ? U[OKeys] : never;\nexport type GetWritableKeys<O extends object> = O extends infer Item ? _Get<Item> : never;",
  "object/is-empty/_temp.ts": "export declare const emptyObjectSymbol: unique symbol;\n",
  "object/is-empty/index.test.ts": "import { Equal, Checker } from '../../utils.tzen';\nimport { IsEmpty } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<IsEmpty<{}>, true>,\n    Equal<IsEmpty<{ a: 1 }>, false>,\n    Equal<IsEmpty<{ a?: 1 }>, false>,\n    Equal<IsEmpty<1>, false>,\n    Equal<IsEmpty<''>, false>,\n    Equal<IsEmpty<null>, false>,\n    Equal<IsEmpty<undefined>, false>,\n    Equal<IsEmpty<never>, false>\n  ]\n>;\n",
  "object/is-empty/index.tzen": "import type { emptyObjectSymbol } from './_temp'\n\ntype EmptyObject = { [_ in emptyObjectSymbol]?: never };\n\nexport type IsEmpty<O: object> = ^{\n  if ([O] == [never]) {\n    return false\n  }\n  \n  return O == EmptyObject ? true : false\n};",
  "object/is-empty/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { emptyObjectSymbol } from './_temp';\ntype EmptyObject = {\n  [_ in emptyObjectSymbol]?: never;\n};\nexport type IsEmpty<O extends object> = ([O] extends [never] ? false : TZ_URS) extends infer r_8l3t ? r_8l3t extends TZ_URS ? O extends EmptyObject ? true : false : r_8l3t : never;",
  "object/set-writable/index.test.ts": "import { Checker, Equal } from '../../utils.tzen';\nimport { SetWritable } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<SetWritable<{ readonly a: number; b: string }, 'a'>, { a: number; b: string }>,\n    Equal<\n      SetWritable<{ readonly a: number; b: string }, 'a' | 'b'>,\n      { a: number; b: string }\n    >,\n    Equal<\n      // @ts-ignore\n      SetWritable<{ readonly a: number; b: string }, 'a' | 'b' | 'c'>,\n      { a: number; b: string; c: unknown }\n    >\n  ]\n>;\n",
  "object/set-writable/index.tzen": "import type { Simplify } from '../simplify/index.tzen'\n\nexport type SetWritable<\n  O: object, \n  Keys: keyof O = keyof O\n> = ^{\n  type TargetValues = Pick<O, Keys>;\n  type FilteredObject = {\n    -readonly [K in keyof TargetValues]: TargetValues[K]\n  }\n  \n  return Simplify<Omit<O, Keys> & FilteredObject>\n}",
  "object/set-writable/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Simplify } from '../simplify/index.tzen';\nexport type SetWritable<O extends object, Keys extends keyof O = keyof O> = [Pick<O, Keys>, {\n  -readonly [K in keyof Pick<O, Keys>]: Pick<O, Keys>[K];\n}] extends [infer TargetValues, infer FilteredObject] ? Simplify<Omit<O, Keys> & FilteredObject> : never;",
  "object/simplify/index.test.ts": "import { Simplify } from './index.tzen';\n\ntype Preview1 = Simplify<{ a: 1; b: 2 } & { c: 3 }>;\ntype Preview2 = Simplify<\n  { a: 1; b: 2 } & {\n    c: {\n      a: 1;\n    } & {\n      b: 2;\n    } & {\n      readonly c: 3;\n    };\n  }\n>;\n",
  "object/simplify/index.tzen": "export type Simplify<O: object> = {\n  [K in keyof O]: ^{\n    type Value = O[K];\n\n    if (Value == object) {\n      return Simplify<Value>;\n    } else {\n      return Value;\n    }\n  }\n} & {};",
  "object/simplify/index.tzen.d.ts": "// @ts-nocheck\n\nexport type Simplify<O extends object> = {\n  [K in keyof O]: [O[K]] extends [infer Value] ? Value extends object ? Simplify<Value> : Value : never;\n} & {};",
  "string/at/index.test.ts": "import type { Checker, Equal } from '../../utils.tzen';\nimport type { At } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<At<'', 0>, undefined>,\n    Equal<At<'a', 0>, 'a'>,\n    Equal<At<'a', 1>, undefined>,\n    Equal<At<'ab', 0>, 'a'>,\n    Equal<At<'ab', 1>, 'b'>,\n  ]\n>;\n",
  "string/at/index.tzen": "import type { Split } from '../split/index.tzen'\n\nexport type At<Str: string, Index: number> = Split<Str, ''>[Index]",
  "string/at/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Split } from '../split/index.tzen';\nexport type At<Str extends string, Index extends number> = Split<Str, ''>[Index];",
  "string/camel-case/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { CamelCase } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<CamelCase<'hello, world123'>, 'helloWorld123'>,\n    Equal<CamelCase<'Foo Bar'>, 'fooBar'>,\n    Equal<CamelCase<'fooBar123-dsfWord'>, 'fooBar123DsfWord'>,\n    Equal<CamelCase<'--foo-bar--'>, 'fooBar'>,\n    Equal<CamelCase<'__FOO_BAR__'>, 'fooBar'>\n  ]\n>;\n",
  "string/camel-case/index.tzen": "import type { SplitWords } from '../split-words/index.tzen'\n\ntype _Handle<\n  Words: string[],\n  Output: string = '',\n  IsFirst: boolean = true\n> = ^{\n  if (Words == [infer F, ...infer R]) {\n    if (IsFirst == true) {\n      return _Handle<R, Uncapitalize<Lowercase<F>>, false>\n    } else {\n      return _Handle<R, `${Output}${Capitalize<Lowercase<F>>}`, false>\n    }\n  } else {\n    return Output\n  }\n}\n\nexport type CamelCase<Str: string> = _Handle<SplitWords<Str>>",
  "string/camel-case/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { SplitWords } from '../split-words/index.tzen';\ntype _Handle<Words extends string[], Output extends string = '', IsFirst extends boolean = true> = Words extends [infer F, ...infer R] ? IsFirst extends true ? _Handle<R, Uncapitalize<Lowercase<F>>, false> : _Handle<R, `${Output}${Capitalize<Lowercase<F>>}`, false> : Output;\nexport type CamelCase<Str extends string> = _Handle<SplitWords<Str>>;",
  "string/ends-with/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { EndsWith } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<EndsWith<'123-', '3-'>, true>,\n    Equal<EndsWith<'123-', '-'>, true>,\n    Equal<EndsWith<'123-', '3'>, false>\n  ]\n>;\n",
  "string/ends-with/index.tzen": "export type EndsWith<Str: string, Target: string> = Str == `${any}${Target}` ? true : false",
  "string/ends-with/index.tzen.d.ts": "// @ts-nocheck\n\nexport type EndsWith<Str extends string, Target extends string> = Str extends `${any}${Target}` ? true : false;",
  "string/index-of/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { IndexOf } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<IndexOf<'', ''>, 0>,\n    Equal<IndexOf<'', 'a'>, -1>,\n    Equal<IndexOf<'a', ''>, 0>,\n    Equal<IndexOf<'01234', '2'>, 2>,\n    Equal<IndexOf<'01234', '3'>, 3>,\n    Equal<IndexOf<'01234--01234', '4', 5>, 11>\n  ]\n>;\n",
  "string/index-of/index.tzen": "import type { GetTailStr } from '../_internal.tzen'\n\ntype _Get<\n  $: { SearchStr: string, Position: number },\n  CurStrSource: string,\n  AccCount: 0[] = [],\n  GreaterThanPos: boolean = false\n> = ^{\n  type CurCount = AccCount['length']\n  type NewAccCount = [...AccCount, 0]\n  \n  if (CurStrSource == '') {\n    return -1\n  } else if (GreaterThanPos == true) {\n    // 找到了目标字符串\n    if (CurStrSource == `${$['SearchStr']}${any}`) {\n      return CurCount\n    } else {\n      // 未找到，继续减一个字符后去查找\n      return _Get<$, GetTailStr<CurStrSource>, NewAccCount, true>\n    }\n  }\n  \n  if (CurCount == $['Position']) {\n    return _Get<$, CurStrSource, AccCount, true>\n  }\n\n  // 即没超 pos 位置，也没到 pos 边界，继续减一个字符后去查找\n  return _Get<$, GetTailStr<CurStrSource>, NewAccCount>\n}\n\nexport type IndexOf<\n  StrSource: string,\n  SearchStr: string,\n  Position: number = 0\n> = ^{\n  if (SearchStr == '') {\n    return 0\n  }\n\n  return _Get<{\n    SearchStr: SearchStr,\n    Position: Position\n  }, StrSource>\n}",
  "string/index-of/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { GetTailStr } from '../_internal.tzen';\ntype _Get<$ extends {\n  SearchStr: string;\n  Position: number;\n}, CurStrSource extends string, AccCount extends 0[] = [], GreaterThanPos extends boolean = false> = [AccCount['length'], [...AccCount, 0]] extends [infer CurCount, infer NewAccCount] ? (CurStrSource extends '' ? -1 : GreaterThanPos extends true ? CurStrSource extends `${$['SearchStr']}${any}` ? CurCount : _Get<$, GetTailStr<CurStrSource>, NewAccCount, true> : TZ_URS) extends infer r_wk2q ? r_wk2q extends TZ_URS ? (CurCount extends $['Position'] ? _Get<$, CurStrSource, AccCount, true> : TZ_URS) extends infer r_lm95 ? r_lm95 extends TZ_URS ? _Get<$, GetTailStr<CurStrSource>, NewAccCount> : r_lm95 : never : r_wk2q : never : never;\nexport type IndexOf<StrSource extends string, SearchStr extends string, Position extends number = 0> = (SearchStr extends '' ? 0 : TZ_URS) extends infer r_3bfr ? r_3bfr extends TZ_URS ? _Get<{\n  SearchStr: SearchStr;\n  Position: Position;\n}, StrSource> : r_3bfr : never;",
  "string/kebab-case/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { KebabCase } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<KebabCase<'hello, world'>, 'hello-world'>,\n    Equal<KebabCase<'hello, world123'>, 'hello-world-123'>,\n    Equal<KebabCase<'foo bar'>, 'foo-bar'>,\n    Equal<KebabCase<'fooBar'>, 'foo-bar'>,\n    Equal<KebabCase<'__FOO_BAR__'>, 'foo-bar'>\n  ]\n>;\n",
  "string/kebab-case/index.tzen": "import type { SplitWords } from '../split-words/index.tzen'\n\ntype _Handle<\n  Words: string[],\n  Output: string = '',\n> = ^{\n  if (Words == [infer F, ...infer R]) {\n    return _Handle<R, Output == '' ? Lowercase<F> : `${Output}-${Lowercase<F>}`>\n  } else {\n    return Output\n  }\n}\n\nexport type KebabCase<Str: string> = _Handle<SplitWords<Str>>",
  "string/kebab-case/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { SplitWords } from '../split-words/index.tzen';\ntype _Handle<Words extends string[], Output extends string = ''> = Words extends [infer F, ...infer R] ? _Handle<R, Output extends '' ? Lowercase<F> : `${Output}-${Lowercase<F>}`> : Output;\nexport type KebabCase<Str extends string> = _Handle<SplitWords<Str>>;",
  "string/length/index.test.ts": "import type { Checker, Equal } from '../../utils.tzen';\nimport type { Length } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Length<''>, 0>,\n    Equal<Length<'a'>, 1>,\n    Equal<Length<'ab'>, 2>,\n    Equal<Length<'abc'>, 3>,\n    Equal<Length<'abcd'>, 4>,\n    Equal<Length<'abcde'>, 5>\n  ]\n>;\n",
  "string/length/index.tzen": "import type { Split } from '../split/index.tzen'\n\nexport type Length<Str: string> = Split<Str, ''>['length']",
  "string/length/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Split } from '../split/index.tzen';\nexport type Length<Str extends string> = Split<Str, ''>['length'];",
  "string/pascal-case/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { PascalCase } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<PascalCase<'hello, world123'>, 'HelloWorld123'>,\n    Equal<PascalCase<'_foo_bar'>, 'FooBar'>,\n    Equal<PascalCase<'__FOO_BAR__'>, 'FooBar'>,\n    Equal<PascalCase<'foo bar'>, 'FooBar'>\n  ]\n>;\n",
  "string/pascal-case/index.tzen": "import type { SplitWords } from '../split-words/index.tzen'\n\ntype _Handle<\n  Words: string[],\n  Output: string = '',\n> = ^{\n  if (Words == [infer F, ...infer R]) {\n    return _Handle<R, `${Output}${Capitalize<Lowercase<F>>}`>\n  } else {\n    return Output\n  }\n}\n\nexport type PascalCase<Str: string> = _Handle<SplitWords<Str>>",
  "string/pascal-case/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { SplitWords } from '../split-words/index.tzen';\ntype _Handle<Words extends string[], Output extends string = ''> = Words extends [infer F, ...infer R] ? _Handle<R, `${Output}${Capitalize<Lowercase<F>>}`> : Output;\nexport type PascalCase<Str extends string> = _Handle<SplitWords<Str>>;",
  "string/repeat/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Repeat } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Repeat<'', 0>, ''>,\n    Equal<Repeat<'-', 3>, '---'>,\n    Equal<Repeat<'-_-', 3>, '-_--_--_-'>,\n    Equal<Repeat<'-_-', 0>, '-_-'>\n  ]\n>;\n\n",
  "string/repeat/index.tzen": "type _Generate<\n  $: { StrSource: string, Count: number },\n  AccCount: 0[] = [], \n  GeneratedStr: string = ''\n> = ^{\n  type CurCount = AccCount['length']\n  if (CurCount == $['Count']) { return GeneratedStr }\n\n  return _Generate<$, \n    [...AccCount, 0],\n    `${GeneratedStr}${$['StrSource']}`\n  >\n}\n\nexport type Repeat<StrSource: string, Count: number> = ^{\n  for (infer S in StrSource) {\n    if (S == '') { return '' }\n    if (Count == 0 | 1) { return S }\n\n    return _Generate<{ StrSource: S, Count: Count }>\n  }\n}",
  "string/repeat/index.tzen.d.ts": "// @ts-nocheck\n\ntype _Generate<$ extends {\n  StrSource: string;\n  Count: number;\n}, AccCount extends 0[] = [], GeneratedStr extends string = ''> = [AccCount['length']] extends [infer CurCount] ? (CurCount extends $['Count'] ? GeneratedStr : TZ_URS) extends infer r_bk0g ? r_bk0g extends TZ_URS ? _Generate<$, [...AccCount, 0], `${GeneratedStr}${$['StrSource']}`> : r_bk0g : never : never;\nexport type Repeat<StrSource extends string, Count extends number> = StrSource extends infer S ? (S extends '' ? '' : TZ_URS) extends infer r_l75o ? r_l75o extends TZ_URS ? (Count extends 0 | 1 ? S : TZ_URS) extends infer r_2czf ? r_2czf extends TZ_URS ? _Generate<{\n  StrSource: S;\n  Count: Count;\n}> : r_2czf : never : r_l75o : never : never;",
  "string/replace/index.test.ts": "import type { Checker, Equal } from '../../utils.tzen';\nimport type { Replace } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Replace<'foobar', 'foo', 'bar'>, 'barbar'>,\n    Equal<Replace<'foobar', 'b', 'a'>, 'fooaar'>,\n    Equal<Replace<'wc\\n1', 'c', 'a'>, 'wa\\n1'>,\n    Equal<Replace<'wc\\n', '\\n', 'a'>, 'wca'>,\n    Equal<Replace<'hello world', 'l', 'L'>, 'heLlo world'>,\n    Equal<Replace<'hello world', 'l', 'L', { all: true }>, 'heLLo worLd'>,\n  ]\n>;\n",
  "string/replace/index.tzen": "interface ReplaceOptions {\n  all?: boolean;\n}\n\nexport type Replace<\n  Str: string,\n  SearchValue: string,\n  ReplaceValue: string,\n  Options: ReplaceOptions = {}\n> = ^{\n  if (Str == `${infer Head}${SearchValue}${infer Tail}`) {\n    type RightValue = Options['all'] == true ? Replace<Tail, SearchValue, ReplaceValue, Options> : Tail;\n    \n    return `${Head}${ReplaceValue}${RightValue}`;\n  }\n\n  return Str;\n}",
  "string/replace/index.tzen.d.ts": "// @ts-nocheck\n\ninterface ReplaceOptions{\n  all?: boolean;\n};\nexport type Replace<Str extends string, SearchValue extends string, ReplaceValue extends string, Options extends ReplaceOptions = {}> = (Str extends `${infer Head}${SearchValue}${infer Tail}` ? [Options['all'] extends true ? Replace<Tail, SearchValue, ReplaceValue, Options> : Tail] extends [infer RightValue] ? `${Head}${ReplaceValue}${RightValue}` : never : TZ_URS) extends infer r_nhpe ? r_nhpe extends TZ_URS ? Str : r_nhpe : never;",
  "string/snake-case/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { SnakeCase } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<SnakeCase<'hello, world'>, 'hello_world'>,\n    Equal<SnakeCase<'hello, world123'>, 'hello_world_123'>,\n    Equal<SnakeCase<'foo bar'>, 'foo_bar'>,\n    Equal<SnakeCase<'fooBar'>, 'foo_bar'>,\n    Equal<SnakeCase<'__FOO_BAR__'>, 'foo_bar'>\n  ]\n>;\n",
  "string/snake-case/index.tzen": "import type { SplitWords } from '../split-words/index.tzen'\n\ntype _Handle<\n  Words: string[],\n  Output: string = '',\n> = ^{\n  if (Words == [infer F, ...infer R]) {\n    return _Handle<R, Output == '' ? Lowercase<F> : `${Output}_${Lowercase<F>}`>\n  } else {\n    return Output\n  }\n}\n\nexport type SnakeCase<Str: string> = _Handle<SplitWords<Str>>",
  "string/snake-case/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { SplitWords } from '../split-words/index.tzen';\ntype _Handle<Words extends string[], Output extends string = ''> = Words extends [infer F, ...infer R] ? _Handle<R, Output extends '' ? Lowercase<F> : `${Output}_${Lowercase<F>}`> : Output;\nexport type SnakeCase<Str extends string> = _Handle<SplitWords<Str>>;",
  "string/split/index.test.ts": "import type { Checker, Equal } from '../../utils.tzen';\nimport type { Split } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Split<'123', ''>, ['1', '2', '3']>,\n    Equal<Split<'123', '1'>, ['', '23']>,\n    Equal<Split<'123', '2'>, ['1', '3']>,\n    Equal<Split<'123', '3'>, ['12', '']>,\n    Equal<Split<'123', '4'>, ['123']>,\n    Equal<Split<'', ''>, []>,\n    Equal<Split<'', '1'>, ['']>,\n    Equal<Split<'1.3.43434.3434', '.'>, ['1', '3', '43434', '3434']>,\n    Equal<Split<'1-3-eee.33-11', '-'>, ['1', '3', 'eee.33', '11']>,\n    Equal<Split<'a->b->c', '->'>, ['a', 'b', 'c']>\n  ]\n>;\n",
  "string/split/index.tzen": "import type { Pop } from '../../array/pop/index.tzen'\nimport type { Cast } from '../../utils.tzen'\n\ntype __Split<Str: string, Delimiter: string, T: string[] = []> = ^{\n  if (Str == `${infer BS}${Delimiter}${infer AS}`) {\n    return __Split<AS, Delimiter, [...T, BS]>\n  } else {\n    return [...T, Str]\n  }\n}\n\ntype _Split<Str: string, Delimiter: string> = ^{\n  type Result = __Split<Str, Delimiter>\n\n  return Delimiter == '' ? Pop<Result> : Result\n}\n\nexport type Split<Str: string, Delimiter: string = ''> = ^{\n  for (infer X in _Split<Str, Delimiter>) {\n    return Cast<X, string[]>\n  }\n}",
  "string/split/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Pop } from '../../array/pop/index.tzen';\nimport type { Cast } from '../../utils.tzen';\ntype __Split<Str extends string, Delimiter extends string, T extends string[] = []> = Str extends `${infer BS}${Delimiter}${infer AS}` ? __Split<AS, Delimiter, [...T, BS]> : [...T, Str];\ntype _Split<Str extends string, Delimiter extends string> = [__Split<Str, Delimiter>] extends [infer Result] ? Delimiter extends '' ? Pop<Result> : Result : never;\nexport type Split<Str extends string, Delimiter extends string = ''> = _Split<Str, Delimiter> extends infer X ? Cast<X, string[]> : never;",
  "string/split-words/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { SplitWords } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<SplitWords<'fred, barney, & pebbles'>, ['fred', 'barney', 'pebbles']>,\n    Equal<\n      SplitWords<'fred, barney, & pebbles, &betty'>,\n      ['fred', 'barney', 'pebbles', 'betty']\n    >,\n    Equal<SplitWords<'helloWORLD, hi, 111'>, ['hello', 'WORLD', 'hi', '111']>,\n    Equal<\n      SplitWords<`Note: This method doesn't set the \"length\" property of bound functions.`>,\n      [\n        'Note',\n        'This',\n        'method',\n        'doesn',\n        't',\n        'set',\n        'the',\n        'length',\n        'property',\n        'of',\n        'bound',\n        'functions'\n      ]\n    >\n  ]\n>;\n",
  "string/split-words/index.tzen": "import type { AlphaLowerCaseChars, AlphaUppercaseChars, NumberChars } from '../_internal.tzen'\n\ntype _Handle<\n  CurStr: string,\n  Output: string[] = [],\n  CurAccWord: string = '',\n  CurWordMode: 'lower' | 'upper' | 'number' | 'other' = 'other'\n> = ^{\n  type GetCurWordMode<CurChar: string> = ^{\n    if (CurChar == AlphaLowerCaseChars) { return 'lower' }\n    else if (CurChar == AlphaUppercaseChars) { return 'upper' }\n    else if (CurChar == NumberChars) { return 'number' }\n    else { return 'other' }\n  }\n\n  if (CurStr == '') {\n    return CurAccWord == '' ? Output : [...Output, CurAccWord]\n  }\n  else {\n    if (CurStr == `${infer F}${infer R}`) {\n      type CurCharMode = GetCurWordMode<F>\n\n      if (CurWordMode == 'other') {\n        if (CurCharMode == 'other') {\n          return _Handle<R, Output>\n        } else {\n          return _Handle<R, Output, F, CurCharMode>\n        }\n      }\n     \n      if (CurCharMode == CurWordMode) {\n        return _Handle<R, Output, `${CurAccWord}${F}`, CurWordMode>\n      } else if (CurCharMode == 'other') {\n        return _Handle<R, [...Output, CurAccWord]>\n      } \n      // 处理 Word 这类单词首字母为大写的特殊情况\n      else if (CurWordMode == 'upper') {\n        // `Wo`\n        if (CurCharMode == 'lower') {\n          return _Handle<R, Output, `${CurAccWord}${F}`, 'lower'>\n        }\n      }\n\n      return _Handle<R, [...Output, CurAccWord], F, CurCharMode>\n    }\n  }\n}\n  \n\nexport type SplitWords<Str: string> = _Handle<Str>",
  "string/split-words/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { AlphaLowerCaseChars, AlphaUppercaseChars, NumberChars } from '../_internal.tzen';\ntype $__Handle_SugarBlock__GetCurWordMode__r_kva8<CurChar extends string> = CurChar extends AlphaLowerCaseChars ? 'lower' : CurChar extends AlphaUppercaseChars ? 'upper' : CurChar extends NumberChars ? 'number' : 'other';\ntype _Handle<CurStr extends string, Output extends string[] = [], CurAccWord extends string = '', CurWordMode extends 'lower' | 'upper' | 'number' | 'other' = 'other'> = CurStr extends '' ? CurAccWord extends '' ? Output : [...Output, CurAccWord] : CurStr extends `${infer F}${infer R}` ? [$__Handle_SugarBlock__GetCurWordMode__r_kva8<F>] extends [infer CurCharMode] ? (CurWordMode extends 'other' ? CurCharMode extends 'other' ? _Handle<R, Output> : _Handle<R, Output, F, CurCharMode> : TZ_URS) extends infer r_0loa ? r_0loa extends TZ_URS ? (CurCharMode extends CurWordMode ? _Handle<R, Output, `${CurAccWord}${F}`, CurWordMode> : CurCharMode extends 'other' ? _Handle<R, [...Output, CurAccWord]> : CurWordMode extends 'upper' ? CurCharMode extends 'lower' ? _Handle<R, Output, `${CurAccWord}${F}`, 'lower'> : TZ_URS : TZ_URS) extends infer r_3b4n ? r_3b4n extends TZ_URS ? _Handle<R, [...Output, CurAccWord], F, CurCharMode> : r_3b4n : never : r_0loa : never : never : never;\nexport type SplitWords<Str extends string> = _Handle<Str>;",
  "string/starts-with/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { StartsWith } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<StartsWith<'123-', '1'>, true>,\n    Equal<StartsWith<'123-', '12'>, true>,\n    Equal<StartsWith<'123-', '1-'>, false>,\n    Equal<StartsWith<'123-', '2'>, false>\n  ]\n>;\n",
  "string/starts-with/index.tzen": "export type StartsWith<Str: string, Target: string> = Str == `${Target}${any}` ? true : false",
  "string/starts-with/index.tzen.d.ts": "// @ts-nocheck\n\nexport type StartsWith<Str extends string, Target extends string> = Str extends `${Target}${any}` ? true : false;",
  "string/substring/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Substring } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Substring<'12345', 1, 3>, '23'>,\n    Equal<Substring<'12345', 0, 3>, '123'>,\n    Equal<Substring<'12345', 0, 5>, '12345'>,\n    Equal<Substring<'12345', 0, 99>, '12345'>,\n    Equal<Substring<'12345', 3>, '45'>,\n    Equal<Substring<'12345', 1>, '2345'>\n  ]\n>;\n",
  "string/substring/index.tzen": "import type { GetTailStr, GetHeadStr } from '../_internal.tzen'\n\ntype _Get<\n  $: { Start: number, End: number;  },\n  CurIteratedStr: string,\n  AccCount: 0[] = [],\n  CurAccStr: string = '',\n  GreaterThanStartPos: boolean = false\n> = ^{\n  type CurCount = AccCount['length'];\n  type NewAccCount = [...AccCount, 0];\n\n  if (CurIteratedStr == '') {\n    return CurAccStr;\n  } else if (CurCount == $['End']) {\n    if (GreaterThanStartPos == true) {\n      return `${CurAccStr}${GetHeadStr<CurIteratedStr>}`;\n    }\n  }\n  \n  if (CurCount == $['Start']) {\n    return _Get<$, \n      CurIteratedStr,\n      NewAccCount,\n      CurAccStr,\n      true\n    >;\n  } else if (GreaterThanStartPos == true) {\n    if (CurIteratedStr == `${infer H}${infer R}`) {\n      return _Get<$, \n        R,\n        NewAccCount,\n        `${CurAccStr}${H}`,\n        true\n      >;\n    }\n  }\n  \n  return _Get<$, GetTailStr<CurIteratedStr>, NewAccCount>;\n}\n\n\nexport type Substring<\n  StrSource: string,\n  Start: number,\n  End: number = -1\n> = ^{\n  if (StrSource == '') {\n    return ''\n  }\n  \n  if (Start == End) {\n    return ''\n  }\n  \n  return _Get<{ Start: Start, End: End }, StrSource>;\n}",
  "string/substring/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { GetTailStr, GetHeadStr } from '../_internal.tzen';\ntype _Get<$ extends {\n  Start: number;\n  End: number;\n}, CurIteratedStr extends string, AccCount extends 0[] = [], CurAccStr extends string = '', GreaterThanStartPos extends boolean = false> = [AccCount['length'], [...AccCount, 0]] extends [infer CurCount, infer NewAccCount] ? (CurIteratedStr extends '' ? CurAccStr : CurCount extends $['End'] ? GreaterThanStartPos extends true ? `${CurAccStr}${GetHeadStr<CurIteratedStr>}` : TZ_URS : TZ_URS) extends infer r_b7rq ? r_b7rq extends TZ_URS ? (CurCount extends $['Start'] ? _Get<$, CurIteratedStr, NewAccCount, CurAccStr, true> : GreaterThanStartPos extends true ? CurIteratedStr extends `${infer H}${infer R}` ? _Get<$, R, NewAccCount, `${CurAccStr}${H}`, true> : TZ_URS : TZ_URS) extends infer r_w9ga ? r_w9ga extends TZ_URS ? _Get<$, GetTailStr<CurIteratedStr>, NewAccCount> : r_w9ga : never : r_b7rq : never : never;\nexport type Substring<StrSource extends string, Start extends number, End extends number = -1> = (StrSource extends '' ? '' : TZ_URS) extends infer r_ftdz ? r_ftdz extends TZ_URS ? (Start extends End ? '' : TZ_URS) extends infer r_0d9e ? r_0d9e extends TZ_URS ? _Get<{\n  Start: Start;\n  End: End;\n}, StrSource> : r_0d9e : never : r_ftdz : never;",
  "string/trim/index.test.ts": "import type { Equal, Checker } from '../../utils.tzen';\nimport type { Trim } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Trim<'  1  '>, '1'>,\n    Equal<Trim<'  1 2  '>, '1 2'>,\n    Equal<Trim<'  1 2 3  '>, '1 2 3'>\n  ]\n>;\n",
  "string/trim/index.tzen": "import type { TrimStart } from \"../trim-start/index.tzen\"\nimport type { TrimEnd } from \"../trim-end/index.tzen\"\n\nexport type Trim<Str: string> = TrimStart<TrimEnd<Str>>",
  "string/trim/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { TrimStart } from \"../trim-start/index.tzen\";\nimport type { TrimEnd } from \"../trim-end/index.tzen\";\nexport type Trim<Str extends string> = TrimStart<TrimEnd<Str>>;",
  "string/trim-end/index.test.ts": "import { Equal, Checker } from '../../utils.tzen';\nimport { TrimEnd } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<TrimEnd<'1 1, 3  '>, '1 1, 3'>,\n    Equal<TrimEnd<'  1  '>, '  1'>,\n    Equal<TrimEnd<'.1-- '>, '.1--'>\n  ]\n>;\n",
  "string/trim-end/index.tzen": "import type { Whitespace } from \"../_internal.tzen\"\n\nexport type TrimEnd<Str: string> = ^{\n  if (Str == `${infer L}${Whitespace}`) {\n    return TrimEnd<L>\n  } else {\n    return Str \n  }\n}",
  "string/trim-end/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Whitespace } from \"../_internal.tzen\";\nexport type TrimEnd<Str extends string> = Str extends `${infer L}${Whitespace}` ? TrimEnd<L> : Str;",
  "string/trim-start/index.test.ts": "import { Equal, Checker } from '../../utils.tzen';\nimport { TrimStart } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<TrimStart<'  11, 3'>, '11, 3'>,\n    Equal<TrimStart<'     1'>, '1'>,\n    Equal<TrimStart<'  1  '>, '1  '>\n  ]\n>;\n",
  "string/trim-start/index.tzen": "import type { Whitespace } from \"../_internal.tzen\"\n\nexport type TrimStart<Str: string> = ^{\n  if (Str == `${Whitespace}${infer R}`) {\n    return TrimStart<R>\n  } else {\n    return Str \n  }\n}",
  "string/trim-start/index.tzen.d.ts": "// @ts-nocheck\n\nimport type { Whitespace } from \"../_internal.tzen\";\nexport type TrimStart<Str extends string> = Str extends `${Whitespace}${infer R}` ? TrimStart<R> : Str;",
  "union/has/index.test.ts": "import { Equal, Checker } from '../../utils.tzen';\nimport { Has } from './index.tzen';\n\ntype _ = Checker<\n  [\n    Equal<Has<1 | 2, 1>, true>,\n    Equal<Has<1 | 2, 3>, false>,\n    Equal<Has<1 | 2 | 3, 1 | 2>, true>,\n    Equal<Has<1 | 2 | 3, 1 | 2 | 3>, true>,\n    Equal<Has<'1' | '2', '1'>, true>,\n    Equal<Has<'1' | '2', '3'>, false>,\n  ]\n>;\n",
  "union/has/index.tzen": "export type Has<U, T> = [T] == [U] ? true : false",
  "union/has/index.tzen.d.ts": "// @ts-nocheck\n\nexport type Has<U, T> = [T] extends [U] ? true : false;"
}
